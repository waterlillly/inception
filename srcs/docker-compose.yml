services:
  nginx:
    build: ./requirements/nginx		          # build custom image instead of pulling from Docker Hub
    container_name: nginx			              # use custom name for container
    ports:							                    # map container ports to host ports
      - "443:443"
    env_file:						                    # specify env-vars in a file (instead of inline)
      - ./.env
    volumes:						                    # mount host paths/named volumes into container at specified path
      - wordpress_data:/var/www/html
    depends_on:						                  # specify dependencies between services to control startup order
      wordpress:
        condition: service_healthy	        # wait for wordpress service to be healthy
    restart: unless-stopped			            # always restart the container unless it is explicitly stopped
    networks:						                    # define custom networks for inter-container communication
      - inception					                  #	(by default all services inside a compose file are in the same network)

  wordpress:
    build: ./requirements/wordpress
    container_name: wordpress
    secrets:						                    # manage sensitive data (e.g., passwords) separately from the code
      - db_user_password
      - wp_admin_password
      - wp_user_password
    env_file:
      - ./.env
    volumes:
      - wordpress_data:/var/www/html
    depends_on:
      mariadb:
        condition: service_healthy
    healthcheck:					                  # check if service is healthy
      test: ["CMD-SHELL", "nc -z 127.0.0.1 9000 || exit 1"]
                                            # scans port to check if php-fpm is listening (without actual data transfer)
      interval: 30s					                # run the test every 30sec
      timeout: 20s					                # fail if test takes longer than 20s to finish
      retries: 3					                  # try 3 times before marking as unhealthy
    restart: unless-stopped
    networks:
      - inception

  mariadb:
    build: ./requirements/mariadb
    container_name: mariadb
    secrets:
      - db_user_password
      - db_root_password
    env_file:
      - ./.env
    volumes:
      - mariadb_data:/var/lib/mysql
    healthcheck:
      test: ["CMD-SHELL", "mysqladmin ping -h localhost -u root -p$$(cat /run/secrets/db_root_password)"]
                                            # mysqladmin (= client utility) pings database to check if it's up
                                            # -u -> specifies to connect as specific user (=root)
                                            # -p -> password for user
                                            # $$ -> escape $ in docker-compose
      interval: 20s
      timeout: 10s
      retries: 3
    restart: unless-stopped
    networks:
      - inception

secrets:
  db_user_password:
    file: ./../secrets/db_user_password
  db_root_password:
    file: ./../secrets/db_root_password
  wp_admin_password:
    file: ./../secrets/wp_admin_password
  wp_user_password:
    file: ./../secrets/wp_user_password

volumes:							                      # define volumes to keep data persistent outside of container lifecycle
  wordpress_data:
    driver: local                           # local is default => volume data gets stored on host machine
    driver_opts:                            # specific options for the local driver
      type: none                            # which filesystem/device type is used (eg.: nfs (remote shared storage), tmpfs (in-memory/ RAM))
      o: bind                               # bind-mount an existing path (eg.: rw/ro = read-/write-only, uid=<uid>,gid=<gid> = set ownership))
      device: /home/${LOGIN}/data/wordpress # <host_path> -> the actual path to mount (has to exist!)
  mariadb_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /home/${LOGIN}/data/mariadb

networks:
  inception:
    driver: bridge	                        # how containers should connect to each other
                                            # bridge: default for standalone containers on a single host
                                            #  -> creates virtual internal network on host machine
                                            #  -> every container gets private IP address from network
                                            #  -> NAT (Network Address Translation) so container can reach internet through host